scriptencoding=utf-8
" vim:set ts=8 sts=2 sw=2 tw=0:
" --------------------------------------------------------------------------

" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

augroup MyAutoCmd
  autocmd!
augroup END

if !has('gui_running')
  set t_Co=256
endif

" let mapleader = ","

if has('vim_starting')
  if &compatible
    set nocompatible               " Be iMproved
  endif
  set runtimepath+=~/.vim/bundle/neobundle.vim/
  set runtimepath+=$GOROOT/misc/vim
  set runtimepath+=$GOPATH/src/github.com/nsf/gocode/vim
endif

" filetype plugin indent off

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle "trusktr/seti.vim"

NeoBundle "itchyny/lightline.vim"

NeoBundle "thinca/vim-ref"

NeoBundle "ctrlpvim/ctrlp.vim"

NeoBundle "nathanaelkane/vim-indent-guides"

NeoBundle "t8keru/vim-bclose"

NeoBundle "Shougo/neosnippet"

NeoBundle "Shougo/neosnippet-snippets"

NeoBundle "scrooloose/syntastic"

NeoBundle "majutsushi/tagbar"

NeoBundle "Lokaltog/vim-easymotion"

NeoBundle "tpope/vim-fugitive"

NeoBundle "tyru/caw.vim"

NeoBundle "Shougo/neocomplete.vim"

NeoBundle "thinca/vim-quickrun"

NeoBundle "tpope/vim-surround"

NeoBundle "Shougo/vimshell"

let g:make = 'gmake'
if system('uname -o') =~ '^GNU/'
  let g:make = 'make'
endif

NeoBundle "Shougo/vimproc", {
      \ "build": {
      \   "windows": "make -f make_mingw64.mak",
      \   "mac": "make -f make_mac.mak",
      \   "unix": g:make
      \ }}

NeoBundleLazy "Shougo/unite.vim", {
      \ "autoload": {
      \   "commands": [
      \     "Unite",
      \     "UniteWithBufferDir"
      \   ]
      \ }}

NeoBundleLazy "Shougo/unite-outline", {
      \ "autoload": {
      \   "unite_sources": [
      \      "outline"
      \   ]
      \ }}

NeoBundleLazy "kmnk/vim-unite-giti", {
      \ "autoload": {
      \   "unite_sources": [
      \     "giti",
      \     "giti/branch",
      \     "giti/branch/new",
      \     "giti/branch_all",
      \     "giti/config",
      \     "giti/log",
      \     "giti/remote",
      \     "giti/status"
      \   ]
      \ }}

NeoBundleLazy "motemen/git-vim", {
      \ "autoload": {
      \   "function_prefix": "git",
      \   "functions": "git#get_current_branch",
      \   "commands": [{
      \       "name": "GitDiff",
      \       "complete": "customlist,git#list_commits"
      \     }, {
      \      "name": "GitVimDiff",
      \      "complete": "customlist,git#list_commits"
      \    }, {
      \      "name": "Git",
      \      "complete": "customlist,git#list_commits"
      \    }, {
      \      "name": "GitCheckout",
      \      "complete": "customlist,git#list_commits"
      \    }, {
      \      "name": "GitAdd",
      \      "complete": "file"
      \    },
      \    "GitLog",
      \    "GitCommit",
      \    "GitBlame",
      \    "GitPus"
      \    ]
      \ }}

NeoBundleLazy "Shougo/vimfiler", {
      \ "depends": [
      \   "Shougo/unite.vim"
      \ ],
      \ "autoload": {
      \   "commands": [
      \     "VimFilerTab",
      \     "VimFiler",
      \     "VimFilerExplorer"
      \   ]
      \ }}

NeoBundleLazy "davidhalter/jedi-vim", {
      \ "autoload": {
      \   "filetypes": [
      \     "python"
      \   ]
      \ }}

NeoBundleLazy "lambdalisue/vim-pyenv", {
      \ "depends": [
      \   "davidhalter/jedi-vim"
      \ ],
      \ "autoload": {
      \   "filetypes": [
      \     "python"
      \   ]
      \ }}

NeoBundleLazy "kana/vim-filetype-haskell", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "eagletmt/ghcmod-vim", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "ujihisa/neco-ghc", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "osyo-manga/vim-watchdogs", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "ujihisa/ref-hoogle", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "ujihisa/unite-haskellimport", {
      \ "autoload": {
      \   "filetypes": [
      \     "haskell"
      \   ]
      \ }}

NeoBundleLazy "mattn/gist-vim", {
      \ "depends": [
      \   "mattn/webapi-vim"
      \ ],
      \ "autoload": {
      \   "commands": [
      \     "Gist"
      \   ]
      \ }}

NeoBundleLazy "derekwyatt/vim-scala", {
      \ "autoload": {
      \   "filetypes": [
      \     "scala"
      \   ]
      \ }}

NeoBundleLazy 'VimClojure', {
      \ "autoload": {
      \   "filetypes": [
      \     "clojure"
      \   ]
      \ }}

NeoBundleLazy "c9s/perlomni.vim", {
      \ "autoload": {
      \   "filetypes": [
      \     "perl"
      \   ]
      \ }}

NeoBundle 'fatih/vim-go'

let s:hooks = neobundle#get_hooks("caw.vim")
function! s:hooks.on_source(bundle)
  nmap <Leader>c <Plug>(caw:i:toggle)
  vmap <Leader>c <Plug>(caw:i:toggle)
endfunction

let s:hooks = neobundle#get_hooks("neocomplete.vim")
function! s:hooks.on_source(bundle)

  let g:acp_enableAtStartup = 0
  " Use neocomplete.
  let g:neocomplete#enable_at_startup = 1
  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

  " Define dictionary.
  let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplete#undo_completion()
  inoremap <expr><C-l>     neocomplete#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function()
    return neocomplete#close_popup() . "\<CR>"
    " For no inserting <CR> key.
    "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
  endfunction
  " <TAB>: completion.
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y>  neocomplete#close_popup()
  inoremap <expr><C-e>  neocomplete#cancel_popup()
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

  " For cursor moving in insert mode(Not recommended)
  "inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
  "inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
  "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
  "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
  " Or set this.
  "let g:neocomplete#enable_cursor_hold_i = 1
  " Or set this.
  "let g:neocomplete#enable_insert_char_pre = 1

  " AutoComplPop like behavior.
  "let g:neocomplete#enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplete#enable_auto_select = 1
  "let g:neocomplete#disable_auto_complete = 1
  "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  autocmd MyAutoCmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd MyAutoCmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd MyAutoCmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd MyAutoCmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd MyAutoCmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

endfunction


nnoremap [unite] <Nop>
nmap U [unite]
nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
nnoremap <silent> [unite]r :<C-u>Unite register<CR>
nnoremap <silent> [unite]m :<C-u>Unite file_mru<CR>
nnoremap <silent> [unite]c :<C-u>Unite bookmark<CR>
nnoremap <silent> [unite]o :<C-u>Unite outline<CR>
nnoremap <silent> [unite]t :<C-u>Unite tab<CR>
nnoremap <silent> [unite]w :<C-u>Unite window<CR>

let s:hooks = neobundle#get_hooks("unite.vim")
function! s:hooks.on_source(bundle)
  " start unite in insert mode
  let g:unite_enable_start_insert = 1
  " use vimfiler to open directory
  call unite#custom_default_action("source/bookmark/directory", "vimfiler")
  call unite#custom_default_action("directory", "vimfiler")
  call unite#custom_default_action("directory_mru", "vimfiler")
  autocmd MyAutoCmd FileType unite call s:unite_settings()
  function! s:unite_settings()
    imap <buffer> <Esc><Esc> <Plug>(unite_exit)
    nmap <buffer> <Esc> <Plug>(unite_exit)
    nmap <buffer> <C-n> <Plug>(unite_select_next_line)
    nmap <buffer> <C-p> <Plug>(unite_select_previous_line)
    let profile_name = substitute(unite#get_current_unite().profile_name, '[-/]', '_', 'g')
    if !empty(profile_name) && has_key(s:unite_hooks, profile_name)
      call s:unite_hooks[profile_name]()
    endif
  endfunction

  let s:unite_hooks = {}
  function! s:unite_hooks.source_giti_status()
    nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
    nnoremap <silent><buffer><expr>gm unite#do_action('commit')
    nnoremap <silent><buffer><expr>ga unite#do_action('stage')
    nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
  endfunction

  function! s:unite_hooks.source_giti_branch()
    nnoremap <silent><buffer><expr>d unite#do_action('delete')
    nnoremap <silent><buffer><expr>D unite#do_action('delete_force')
  endfunction

  function! s:unite_hooks.source_giti_branch_all()
    call s:unite_hooks.source_giti_branch()
  endfunction

  function! s:unite_hooks.source_giti_log()
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>d unite#do_action('diff')
  endfunction
endfunction

let s:hooks = neobundle#get_hooks('git-vim')
function! s:hooks.on_source(bundle)
  let g:git_bin = executable('hub') ? 'hub' : 'git'
  let g:git_command_edit = 'vnew'
  let g:git_no_default_mappings = 1
endfunction

let s:hooks = neobundle#get_hooks('vim-fugitive')
function! s:hooks.on_source(bundle)
  autocmd MyAutoCmd FileType fugitiveblame vertical res 25
  autocmd MyAutoCmd FileType gitcommit,git-diff nnoremap <buffer>q :q<CR>
  let g:fugitive_git_executable = executable('hub') ? 'hub' : 'git'
endfunction
function! s:hooks.on_post_source(bundle)
  call fugitive#detect(expand('<amatch>:p'))
endfunction
command! FugitiveReload call fugitive#detect(expand('<amatch>:p'))

" vim-unite-giti
nnoremap <silent>gl :Unite giti/log -no-start-insert -horizontal<CR>
nnoremap <silent>gP :Unite giti/pull_request/base -no-start-insert -horizontal<CR>
nnoremap <silent>gs :Unite giti/status -no-start-insert -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all -no-start-insert<CR>

" close vimfiler automatically when there are only vimfiler open
let s:hooks = neobundle#get_hooks("vimfiler")
function! s:hooks.on_source(bundle)
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_enable_auto_cd = 1

  let g:vimfiler_ignore_pattern = '\%(\.hg\|\.git\|\.bzr\|\.svn\|\.pyc\|\.class\|\.obj\|\.hi\|\.o\|\.a\|\.exe\)$'

  " vimfiler specific key mappings
  autocmd MyAutoCmd FileType vimfiler call s:vimfiler_settings()
  function! s:vimfiler_settings()
    " ^^ to go up
    nmap <buffer> ^^ <Plug>(vimfiler_switch_to_parent_directory)
    " use R to refresh
    nmap <buffer> R <Plug>(vimfiler_redraw_screen)
    " overwrite C-l
    nmap <buffer> <C-l> <C-w>l
  endfunction
endfunction
nnoremap <Leader>e :VimFilerExplorer<CR>
autocmd MyAutoCmd BufEnter * if (winnr('$') == 1 && &filetype ==# 'vimfiler') | q | endif

let s:hooks = neobundle#get_hooks('vim-easymotion')
function! s:hooks.on_source(bundle)
  nmap f <Plug>(easymotion-s2)
  map <Leader>j <Plug>(easymotion-j)
  map <Leader>k <Plug>(easymotion-k)
endfunction

let s:hooks = neobundle#get_hooks("vim-quickrun")
function! s:hooks.on_source(bundle)
  let g:quickrun_config = {
        \ "_": {
        \   "runner": "vimproc",
        \   "runner/vimproc/updatetime" : 10,
        \   "outputter/buffer/close_on_empty" : 1,
        \ },
        \ "cpp/clang++" : {
        \   "hook/time/enable" : 1
        \ },
        \ "cc/clang" : {
        \   "hook/time/enable" : 1
        \ }
        \}
endfunction
nmap <Leader>r <Plug>(quickrun)


let s:hooks = neobundle#get_hooks("jedi-vim")
function! s:hooks.on_source(bundle)
  echo bundle
  setlocal omnifunc=jedi#completions
  "let g:jedi#popup_select_first=0
  let g:jedi#completions_enabled = 0
  " let g:neocomplete#force_omni_input_patterns.python = '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
  let g:jedi#auto_vim_configuration = 0
  let g:jedi#rename_command = '<Leader>R'
  let g:jedi#goto_assignments_command = '<Leader>G'
endfunction

let s:hooks = neobundle#get_hooks("vim-indent-guides")
function! s:hooks.on_source(bundle)
  let g:indent_guides_guide_size = 1
endfunction

let s:hooks = neobundle#get_hooks("VimClojure")
function! s:hooks.on_source(bundle)
  let vimclojure#HighlightBuiltins=1
  let vimclojure#HighlightContrib=1
  let vimclojure#DynamicHighlighting=1
  let vimclojure#ParenRainbow=1
  let vimclojure#WantNailgun = 1
  let vimclojure#NailgunClient = "ng"
endfunction




" -----------------------------------------------------------------------------
function! s:golang_init()
  setl sw=4
  setl sts=4
  setl ts=4
  setl noexpandtab
  let g:syntastic_go_checkers = ['go', 'golint']
  nmap <Leader>t :TagbarToggle<CR>
  let g:tagbar_type_go = {
        \ 'ctagstype' : 'go',
        \ 'kinds'     : [
        \   'p:package',
        \   'i:imports:1',
        \   'c:constants',
        \   'v:variables',
        \   't:types',
        \   'n:interfaces',
        \   'w:fields',
        \   'e:embedded',
        \   'm:methods',
        \   'r:constructor',
        \   'f:functions'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
        \   't' : 'ctype',
        \   'n' : 'ntype'
        \ },
        \ 'scope2kind' : {
        \   'ctype' : 't',
        \   'ntype' : 'n'
        \ },
        \ 'ctagsbin'  : 'gotags',
        \ 'ctagsargs' : '-sort -silent'
        \ }
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType go call s:golang_init()


" --------------------------------------------------------------------------------
function! s:ruby_init()
  setl sw=2
  setl sts=2
  setl ts=2
  setl expandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType ruby call s:ruby_init()


" --------------------------------------------------------------------------------
function! s:haskell_init()
  setl sw=2
  setl sts=2
  setl ts=2
  setl expandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType haskell call s:haskell_init()


function! s:php_init()
  setl ci
  setl ai
  setl si
  setl sw=4
  setl sts=4
  setl ts=4
  setl noexpandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType php call s:php_init()

call neobundle#end()

" Required:
filetype plugin indent on
syntax on

NeoBundleCheck

set relativenumber
set colorcolumn=80
set cursorline
set tabstop=8
set expandtab
set autoindent
set backspace=indent,eol,start
set wrapscan
set showmatch
set wildmenu
set formatoptions+=mM
set matchpairs& matchpairs+=<:>

set shiftround
set infercase
set virtualedit=all
set hidden
set switchbuf=useopen
set matchtime=3

"---------------------------------------------------------------------------
set number
set ruler
set list
set listchars=tab:>-,trail:-,extends:<
set nowrap
set laststatus=2
set cmdheight=2
set showcmd
set title
set hlsearch

colorscheme seti

set foldmethod=marker

set nobackup
set noswapfile
set noundofile

if has('unnamedplus')
  set clipboard& clipboard+=unnamedplus,unnamed
else
  set clipboard& clipboard+=unnamed
endif

"---------------------------------------------------------------------------

scriptencoding=utf-8
" vim:set ts=8 sts=2 sw=2 tw=0:
" --------------------------------------------------------------------------

augroup MyAutoCmd
  autocmd!
augroup END

if !has('gui_running')
  set t_Co=256
endif

" let mapleader = ","

if has('vim_starting')
  set nocompatible
  if empty($GOROOT)
    let $GOROOT=$HOME.'/local/go'
    let $GOPATH=$HOME.'/dev'
    let $GOOS='freebsd'
    let $GOARCH='amd64'
    let $PATH=$GOPATH.'/bin:~/.cabal/bin:~/.pyenv/shims:'.$PATH
  endif
  set runtimepath+=~/.vim/bundle/neobundle.vim/
  set runtimepath+=$GOROOT/misc/vim
  set runtimepath+=$GOPATH/src/github.com/nsf/gocode/vim
endif


filetype plugin indent off

function! s:yaml_load(filename)
python << EOS
import vim, yaml
with open(vim.eval('a:filename'), 'r') as f:
    obj = yaml.load(f)
    obj_hash = str(obj).replace('None', '{}')
    vim.command('let l:ret = %s' % obj_hash)
EOS
  return l:ret
endfunction


" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

let s:my_bundle = s:yaml_load(expand('~/.vim/bundle.yml'))
for bundle in s:my_bundle
  for [bundle_source_name, bundle_command_dict] in items(bundle)
    let s:command_pair = items(bundle_command_dict)
    let s:bundle_command = s:command_pair[0][0]
    let s:bundle_options = s:command_pair[0][1]
    execute s:bundle_command . ' "' . bundle_source_name . '", ' . string(s:bundle_options)
  endfor
endfor

let g:neocomplete#enable_at_startup = 1
let s:hooks = neobundle#get_hooks("neocomplete.vim")
function! s:hooks.on_source(bundle)
  let g:acp_enableAtStartup = 0
  let g:neocomplet#enable_smart_case = 1
endfunction


nnoremap [unite] <Nop>
nmap U [unite]
nnoremap <silent> [unite]f :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
nnoremap <silent> [unite]r :<C-u>Unite register<CR>
nnoremap <silent> [unite]m :<C-u>Unite file_mru<CR>
nnoremap <silent> [unite]c :<C-u>Unite bookmark<CR>
nnoremap <silent> [unite]o :<C-u>Unite outline<CR>
nnoremap <silent> [unite]t :<C-u>Unite tab<CR>
nnoremap <silent> [unite]w :<C-u>Unite window<CR>

let s:hooks = neobundle#get_hooks("unite.vim")
function! s:hooks.on_source(bundle)
  " start unite in insert mode
  let g:unite_enable_start_insert = 1
  " use vimfiler to open directory
  call unite#custom_default_action("source/bookmark/directory", "vimfiler")
  call unite#custom_default_action("directory", "vimfiler")
  call unite#custom_default_action("directory_mru", "vimfiler")
  autocmd MyAutoCmd FileType unite call s:unite_settings()
  function! s:unite_settings()
    imap <buffer> <Esc><Esc> <Plug>(unite_exit)
    nmap <buffer> <Esc> <Plug>(unite_exit)
    nmap <buffer> <C-n> <Plug>(unite_select_next_line)
    nmap <buffer> <C-p> <Plug>(unite_select_previous_line)
    let profile_name = substitute(unite#get_current_unite().profile_name, '[-/]', '_', 'g')
    if !empty(profile_name) && has_key(s:unite_hooks, profile_name)
      call s:unite_hooks[profile_name]()
    endif
  endfunction

  let s:unite_hooks = {}
  function! s:unite_hooks.source_giti_status()
    " nnoremap <silent><buffer><expr>gM unite#do_action('ammend')
    " nnoremap <silent><buffer><expr>gm unite#do_action('commit')
    nnoremap <silent><buffer><expr>ga unite#do_action('stage')
    nnoremap <silent><buffer><expr>gc unite#do_action('checkout')
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>gu unite#do_action('unstage')
  endfunction

  function! s:unite_hooks.source_giti_branch()
    nnoremap <silent><buffer><expr>d unite#do_action('delete')
    nnoremap <silent><buffer><expr>D unite#do_action('delete_force')
  endfunction

  function! s:unite_hooks.source_giti_branch_all()
    call s:unite_hooks.source_giti_branch()
  endfunction

  function! s:unite_hooks.source_giti_log()
    nnoremap <silent><buffer><expr>gd unite#do_action('diff')
    nnoremap <silent><buffer><expr>d unite#do_action('diff')
  endfunction
endfunction

let s:hooks = neobundle#get_hooks('git-vim')
function! s:hooks.on_source(bundle)
  let g:git_bin = executable('hub') ? 'hub' : 'git'
  let g:git_command_edit = 'vnew'
  let g:git_no_default_mappings = 1
endfunction

let s:hooks = neobundle#get_hooks('vim-fugitive')
function! s:hooks.on_source(bundle)
  augroup MyGitCmd
    autocmd!
    autocmd FileType fugitiveblame vertical res 25
    autocmd FileType gitcommit,git-diff nnoremap <buffer>q :q<CR>
  augroup END

  let g:fugitive_git_executable = executable('hub') ? 'hub' : 'git'
endfunction

function! s:hooks.on_post_source(bundle)
  call fugitive#detect(expand('<amatch>:p'))
endfunction

command! FugitiveReload call fugitive#detect(expand('<amatch>:p'))

" vim-unite-giti
nnoremap <silent>gl :Unite giti/log -no-start-insert -horizontal<CR>
nnoremap <silent>gP :Unite giti/pull_request/base -no-start-insert -horizontal<CR>
nnoremap <silent>gs :Unite giti/status -no-start-insert -horizontal<CR>
nnoremap <silent>gh :Unite giti/branch_all -no-start-insert<CR>

" close vimfiler automatically when there are only vimfiler open
autocmd MyAutoCmd BufEnter * if (winnr('$') == 1 && &filetype ==# 'vimfiler') | q | endif
let s:hooks = neobundle#get_hooks("vimfiler")
function! s:hooks.on_source(bundle)
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_enable_auto_cd = 1

  let g:vimfiler_ignore_pattern = "\%(^\..*\|\.pyc$\)"

  " vimfiler specific key mappings
  autocmd MyAutoCmd FileType vimfiler call s:vimfiler_settings()
  function! s:vimfiler_settings()
    " ^^ to go up
    nmap <buffer> ^^ <Plug>(vimfiler_switch_to_parent_directory)
    " use R to refresh
    nmap <buffer> R <Plug>(vimfiler_redraw_screen)
    " overwrite C-l
    nmap <buffer> <C-l> <C-w>l
  endfunction
endfunction
nnoremap <Leader>e :VimFilerExplorer<CR>

let s:hooks = neobundle#get_hooks('vim-easymotion')
function! s:hooks.on_source(bundle)
  nmap f <Plug>(easymotion-s2)
  map <Leader>j <Plug>(easymotion-j)
  map <Leader>k <Plug>(easymotion-k)
endfunction

let s:hooks = neobundle#get_hooks("vim-quickrun")
function! s:hooks.on_source(bundle)
  let g:quickrun_config = {
        \ "_": {"runner": "remote/vimproc"},
        \ "cpp/clang++" : {
        \   "hook/time/enable" : 1
        \ },
        \ "cc/clang" : {
        \   "hook/time/enable" : 1
        \ }
        \}
endfunction
nmap <Leader>r <Plug>(quickrun)


let s:hooks = neobundle#get_hooks("jedi-vim")
function! s:hooks.on_source(bundle)
  setlocal omnifunc=jedi#completions
  "let g:jedi#popup_select_first=0
  let g:jedi#completions_enabled = 0
  " let g:neocomplete#force_omni_input_patterns.python = '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
  let g:jedi#auto_vim_configuration = 0
  let g:jedi#rename_command = '<Leader>R'
  let g:jedi#goto_assignments_command = '<Leader>G'
endfunction

let s:hooks = neobundle#get_hooks("vim-indent-guides")
function! s:hooks.on_source(bundle)
  let g:indent_guides_guide_size = 1
endfunction

" --------------------------------------------------------------------------------
function! s:golang_init()
  let g:syntastic_go_checkers = ['go', 'golint']
  nmap <Leader>t :TagbarToggle<CR>
  let g:tagbar_type_go = {
        \ 'ctagstype' : 'go',
        \ 'kinds'     : [
        \   'p:package',
        \   'i:imports:1',
        \   'c:constants',
        \   'v:variables',
        \   't:types',
        \   'n:interfaces',
        \   'w:fields',
        \   'e:embedded',
        \   'm:methods',
        \   'r:constructor',
        \   'f:functions'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
        \   't' : 'ctype',
        \   'n' : 'ntype'
        \ },
        \ 'scope2kind' : {
        \   'ctype' : 't',
        \   'ntype' : 'n'
        \ },
        \ 'ctagsbin'  : 'gotags',
        \ 'ctagsargs' : '-sort -silent'
        \ }
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType go call s:golang_init()


" --------------------------------------------------------------------------------
function! s:ruby_init()
  setl sw=2
  setl sts=2
  setl ts=2
  setl expandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType ruby call s:ruby_init()


" --------------------------------------------------------------------------------
function! s:haskell_init()
  " let g:haddock_docdir="C:/Apps/HaskellPlatform/2013.2.0.0/doc/html"
  " let g:haddock_browser="chrome.exe"
  " let g:ghc="ghc"
  " compiler ghc
  setl sw=2
  setl sts=2
  setl ts=2
  setl expandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType haskell call s:haskell_init()


function! s:php_init()
  setl ci
  setl ai
  setl si
  setl sw=4
  setl sts=4
  setl ts=4
  setl noexpandtab
  IndentGuidesEnable
  NeoCompleteEnable
endfunction
autocmd MyAutoCmd FileType php call s:php_init()

call neobundle#end()

" Required:
filetype plugin indent on
syntax on

NeoBundleCheck

set relativenumber
set colorcolumn=80
set cursorline
set tabstop=8
set expandtab
set autoindent
set backspace=indent,eol,start
set wrapscan
set showmatch
set wildmenu
set formatoptions+=mM
set matchpairs& matchpairs+=<:>

set shiftround
set infercase
set virtualedit=all
set hidden
set switchbuf=useopen
set matchtime=3

"---------------------------------------------------------------------------
set number
set ruler
set list
set listchars=tab:>-,trail:-,extends:<
set nowrap
set laststatus=2
set cmdheight=2
set showcmd
set title

colorscheme seti
set background=dark

set foldmethod=marker

set nobackup
set noswapfile
set noundofile

if has('unnamedplus')
  set clipboard& clipboard+=unnamedplus,unnamed
else
  set clipboard& clipboard+=unnamed
endif

"---------------------------------------------------------------------------
